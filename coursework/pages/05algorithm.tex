\subsection{Дополнительные обозначения}
\begin{enumerate}
    \item $D= \left( d_1, d_2, \dots, d_l \right)$, где $l$ - количество вершин, доступных для добавления(т.е. у которых нет предшественников в графе $G$) - множество вершин, доступных для добавления в расписание.
    \item $k$ - вектор длин критических путей от ``головной'' вершины до каждой вершины графа.
    \item $\left( s_i, p_i \right)$ - пара, состоящая из номера процессора $p_i$ и время старта задачи $s_i$, то есть достаточное количество информации для размещения работы в расписании.
\end{enumerate}
\subsubsection{Жадные критерии}
\begin{enumerate}
    \item $GR1$ - критерий, используемый в выборе работы на постановку
    \item $GR2$ - критерий, используемый в выборе места постановки работы в расписание
\end{enumerate}
\subsubsection{Процедуры ограниченного перебора}
\begin{enumerate}
    \item $H1$ - процедура перебора для создания места для постановки работы. Минимизируемый критерий - $s_i$
    \item $H2$ - процедура перебора для приближения времени старта работы к длине критического пути до нее. Минимизируемый критерий - $\sum s_k$, где $s_k$ - времена начала $k$ последних добавленных работ.
\end{enumerate}

\subsection{Содержательное описание алгоритма}
\begin{enumerate}
    \item Сформировать множество вершин, у которых нет предшественников. Множество $D = \left( d_1, d_2 \dots d_i \right)$ где $d_i$ – номер работы, доступной для добавления в расписание (т.е. у которой нет предшественников в исходном графе)
    \item В случае, если в множестве $D$ одна вершина – обозначим ее за $d$, в противном случае – создадим фиктивную вершину с нулевой длительностью, у которой все потомки будут из множества $D$, и обозначим ее за $d$
          \begin{figure}[H]
              \ctikzfig{fictive_nodes}
              \caption{Добавление фиктивной вершины}
          \end{figure}
    \item Зададим вектор $k$ – вектор длин критических путей до вершин от $d$. При помощи алгоритма Дейкстры этот вектор заполняется значениями $k_i$, где $i$ – номер вершины. Поскольку алгоритм Дейкстры работает со взвешенными графами, каждое ребро получает вес минимального времени работы на вычислительной системе вершины, из которой исходит
    \item \label{itm:calcD} По жадному критерию $GC1$ выбирается работа из множества $D$ для размещения в расписании. Пусть выбранная работа – $d_i$
          \begin{figure}[H]
              \ctikzfig{max_children}
              \caption{Выбор вершины в соответствии с жадным критерием $GC1$}
          \end{figure}
    \item Производится пробное размещение работы $d$ в расписании с учетом жадного критерия $GC2$ и дополнительных ограничений. В случае, если не получилось найти подходящее место для работы – запускается процедура ограниченного перебора $H1$. Становится известно $s$ – время старта работы и $p$ – процессор, на котором работа выполняется.
    \item Если $s_i$ больше длины критического пути (с точностью до $\Delta$, где $\Delta$ – параметр алгоритма), то вызывается процедура ограниченного перебора $H2$. Если работу разместить не удалось – завершить алгоритм. Если $s_i$ не превосходит длину критического пути (с точностью $\Delta$), то работа размещается в расписании.
    \item $d_i$ удаляется из списка размещенных работ и в графе $G$ удаляется соответствующая вершина и все дуги, исходящие из нее.
    \item Обновляется множество $D$. Если $D$ не пустое, то алгоритм переходит на пункт \ref{itm:calcD}.
\end{enumerate}
\subsubsection{Жадный критерий выбора работы $GC1$}
\begin{itemize}
    \item Максимальное количество потомков у работы
\end{itemize}
Такой выбор работы позволяет открыть максимально возможное количество кандидатов на следующую постановку задачи в расписание, а значит с минимальной вероятностью закрывает путь к оптимальному решению.
\subsubsection{Жадный критерий выбора места работы в расписании $GC2$}
\begin{itemize}
    \item Скорейшее завершение частично построенного расписания
\end{itemize}
\subsubsection{Выбор места работы в расписании} \label{sec:get_crit}
\begin{itemize}
    \item Взвешенная сумма. Например, при вычислении расписания с дополнительным ограничением на количество передач:
          \begin{gather*}
              crit = C_1 \cdot GC2 + C_2 \cdot CR + C_3 \cdot CR2
          \end{gather*}
          А задачи с дополнительным ограничением на сбалансированность ограничения работ:
          \begin{gather*}
              crit = C_1 \cdot GC2 + C_2 \cdot BF
          \end{gather*}
          где $C_1$, $C_2$ и $C_3$ - параметры алгоритма. Работа размещается на место с наибольшим значением параметра $crit$.
    \item Допускная система выбора
          \begin{enumerate}
              \item Список мест размещения работ ранжируется по $GC2$, после чего отсекаются верхние $n\%$ работ, где $n$ - параметр алгоритма
              \item Такие же действия повторяются для каждого дополнительного ограничения
              \item В конечном списке выбрать место по жадному критерию
          \end{enumerate}
\end{itemize}
При ранжировании задач по взвешенной сумме возможна ситуация, при которой будет выбрано место которое хорошо проходит по одному критерию, но очень плохо по другому и тогда расписание будет строиться в направлении ложного минимума. Поэтому в программной реализации было выбрано использование допускной системы выбора.
\subsubsection{Ограниченный перебор}
После неудачной пробной постановки работы в расписание алгоритм создает набор $K = \left( k_1, k_2, \dots, k_t \right)$, состоящий из $t$ последних добавленных работ ($t$ – параметр алгоритма). Далее, процедурой полного перебора пробуются различные расписания до тех пор, пока не получится расписание, удовлетворяющее критерию критичности пути до последней поставленной работы и удовлетворяющее дополнительным ограничениям.
\subsubsection{Расчет времени начала работы}
Для того, чтобы рассчитать время начала  для конкретной работы на процессоре $p$ требуется:
\begin{enumerate}
    \item Вычислить вектор $PJ_{k=1}^L$, где $L$ – количество предшественников у работы. Элементами этого вектора будут являться суммы вида $s_k + C_{kr} + D_{rj}$, где $r$ – номер процессора, на котором размещен предшественник.
    \item Максимумом этого вектора и будет являться первое доступное начало выполнения работы на данном процессоре. $n_j=\max{PJ}$
\end{enumerate}

После расчета возможного времени начала $n_j$ на каждом процессе требуется найти первое возможное время на процессоре. Для этого для каждой работе, которая следует после $n_j$ берутся все окончания работ и расчитывается, есть ли последующая работа, которая начинается до возможного окончания работа. Если да, то работу возможно разместить в этом “слоте”. Иначе, рассматреть окончание следующей работы. Заметим, что всегда можно разместит работу в конец расписания на процессоре.
% \subsection{Блок-схема алгоритма}
{\small
\begin{figure}
    \label{fig:block-scheme}
    \caption{Блок-схема алгоритма}
    \ctikzfig{main-block-schema}
\end{figure}
}