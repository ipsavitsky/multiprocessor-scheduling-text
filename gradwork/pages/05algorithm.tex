\subsection{Алгоритмы построения расписания}
\subsubsection{Описание жадных алгоритмов построения многопроцессорного расписания} \label{algo_template}
Жадные алгортмы, представленные в данной работе, построены по следующей схеме:
\begin{enumerate}
    \item \label{GC1} Выбрать работу для постановки в расписание.
    \item \label{GC2} Выбрать процессор и время начала выполнения задачи из п.\ref{GC1} на выбранном процессоре.
    \item Поставить работу на процессор.
    \item Остановиться, если все задачи поставлены, иначе перейти к п.\ref{GC1}
\end{enumerate}

\subsubsection{Жадный алгоритм} \label{Greedy_GC1}
Жадный алгоритм следует общей схеме, описанной в \ref{algo_template}

Эту схему можно уточнить путем выбора критерия отбора в п.\ref{GC1} и критерия выбора процессора и начала времени выполнения в п.\ref{GC2}. Для постановки задачи с дополнительными ограничениями, такого как $CR$, так же может быть неудача в постановки задачи в раписание, в случае невозможности постановки без нарушения дополнительного ограничения. В таком случае, алгоритм завершается.

Задача $d_i$ наывается \textbf{доступной для постановки} в расписание, в случае, если либо у нее нет предшественников, либо все ее предшественники уже постановлены в расписание. Назовем множеством всех доступных для постановки задач $D = \left( d_0, d_1, \ldots, d_n \right)$.

Жадный алгоритм выбирает задачу для постановки по следующему критерию: пусть $Succ(d)$ - функция, определяющая количество непосредственных последователей работы в графе. Тогда $\forall d_j \in D, d_j \neq d_i: Succ(d_j) < Succ(d_i)$.

\begin{figure}[!htbp]
    \ctikzfig{max_children}
    \caption{}
    \label{fig:max-children}
\end{figure}
На рисунке \ref{fig:max-children} $D = \left( x_1, x_2 \right)$, из которых $Succ(x_1) = 2, Succ(x_2) = 1$. На постановку будет выбрана вершина $x_1$. 

Для постановки с дополнительным ограничением $CR$ жадный алгоритм берет распределение работ по процессорам из специального алгоритма распределения (описание алгоритма приведено в разделе \ref{METIS}), поэтому выбор процессора в п.\ref{GC2} всегда заранее детерминирован. Выбор начала выполнения работы в расписание производится в соответствии с алгоритмом постановки задачи на процессор (описание алгоритма приведено в разделе \ref{gap_filling}).

Для постановки без дополнительных ограничений, жадный алгоритм производит пробную постановку на каждый процессор и выбирает процессор с самым ранним временем завершения работы с учетом алгоритма постановки задачи на процессор (описание алгоритма приведено в разделе \ref{gap_filling}). 

\subsubsection{Жадный алгоритм с EDF эвристикой} \label{Greedy_EDF}
Данный алгоритм следует общей схеме, описанной в пункте \ref{algo_template}, однако отличается от алгоритма, описанного в пункте \ref{Greedy_GC1} критерием выбора работы на постановку.

Эвристика ``саммый ранний директивный срок первый'' (earliest deadline first, или \textbf{EDF}) упорядочивает работы по возрастанию директивных сроков и выбирает работу с нименьшим директивным сроком на постановку. Однако, постановка задачи не предполагает у задач директивных сроков, поэтому в данном алгоритме у каждой работы строятся фиктивные директивные сроки.

В случае, если существует директивный срок всего расписания $d$, то директивный срок $d_A$ работы $A$ может быть рассчитан следующим образом (при известном распределении работ на процессоры):
\begin{enumerate}
    \item \label{find_path} Найти длиннейший путь в графе потока управления от $A$ до работы $S: Succ(S) = \emptyset$.
    \item Рассчитать длину этого пути. Длина пути равна сумме всех передач задержек данных и времен выполнения работ. Задержки передач данных известны, так как известно распределение работ на процессоры. Пусть длина этого пути равна $p$.
    \item $d_A \coloneqq d - p$
\end{enumerate}
Видно, что работа $A$ должна завершиться до $d_A$; иначе путь, найденный в п.\ref{find_path} завершится позже, чем $d$, даже если процессоры ни имеют никакой другой нагрузки, кроме этих работ.

Даже без изветсного директивного срока расписания, EDF эвристика все еще может быть использована для сортировки работ по уменьшению ``потенциальной длины пути  до конца расписания'', учитывая, что расписание всегда завершится какой-либо работой $S : Succ(S) = \emptyset$. Также, нет необходимости вводить настоящие директивные сроки, в которые работы должны быть завершены. Таким образом, можно выставить директивный срок распсиания в $0$, и получить формальные директивные сроки по алгоритму, представленному выше. Такие директивные сроки могут быть отрицательными, что не препятствуует сортировать работы по их возрвствнию.

Описанный алгоритм без модификаций применим к задаче с дополнительным ограничением $CR$, поскольку распределение работ на процессоры может быть рассчитано заранее, и поэтому, время задержек межпроцессорных передач известно заранее. Для данных с однородными процессорами строится взвешенное разбиение (\ref{METIS}), для постановки с неоднородными процессорами строится невзвешенное разбиение, которое впоследствии улучшается алгоритмом локальной оптимизации (\ref{partition_optimization}). 

Однако, для постановки задачи без дополнительных ограничений привязка задач к процессорам заранее неизвестна, поэтому, для вычисления директивных сроков не учитываются задержки межпроцессорной передачи данных, а время выполнения данной задачи считается усредненным по всем процессорам. Например, если в системе три процессора, на которых задача выполняется 1, 1 и 4 у.е., то для рассчета директивного срока время выполнения данной задачи считается $(1+1+4)/3 = 2$. Такая аппроксимация не нарушает работу алгоритма, поскольку директивные сроки требуется только для сортировки работ.

Жадный алгоритм с EDF эвристикой начинается с вычисления фиктивных директивных сроков, после чего выполняется цикл, описанный в \ref{algo_template}.

Еще не добавленная работа с минимальным фиктивным директивным сроком выбирается как очередной кандидат на добавление в расписание. 

Аналогично алгоритму, описанному в \ref{Greedy_GC1}, для задачи с дополнительным ограничением $CR$ для выбора процессора для постановки очередной задачи используется распределение, построенное алгоритмом распределения задач на процессоры (\ref{METIS}), а для постановки без дополнительных ограничений производит пробную постановку на каждый процессор с самым ранним временем завершения работы с учетом алгоритма постановки задачи на процессор (\ref{gap_filling}).

\subsection{Вспомогательные алгоритмы}

\subsubsection{Алгоритм локальной оптимизации разбиения} \label{partition_optimization}

Этот алгоритм используется только для постановки $CR$ с неоднородными процессорами. Подразумевается, что процессоры упорядочены по возрастанию производительности, то есть для любых процессоров $P_1, P_2$, если работа $A$ выполняется на процессоре $P_1$ дольше, чем на $P_2$, то и работа $B$ выполняется на процессоре $P_1$ дольше, чем на $P_2$. Таким образом, если переназначить работу с $P_1$ на $P_2$, то время выполнения расписания сократится.

С примерно равным количеством работ на всех процессорах на невзвешенном разбиении METIS, самые медленные процессору будут самыми загруженными. Задача данного алгоритма - "разгрузить" самые загруженные процессоры путем перемещания раот с него на менее загруженные процессоры. 

Алгоритм имет следующую структуру:
\begin{enumerate}
    \item Выбрать самый загруженный процессор $P_1$
    \item Для каждой работы $A$, поставленной на $P_1$, в порядке убывания времени выполнения:
    \begin{enumerate}
        \item \label{item:choose_proc} Выбрать самый быстрый процессор $P_2$ из процессоров, удовлетворяющих следующее условие: если перенести работу $A$ с $P_1$ на $P_2$, то $\max(\text{загрузка} P_1, \text{загрузка} P_2)$ уменьшается и выполняется ограничение $CR$
        \item Если такой $P_2$ был найден, то перенести эту задачу и перейти к пункту \ref{item:choose_proc}; иначе рассмотреть следующую по времени выполнения задачу на $P_1$.
    \end{enumerate}
    \item Если задачи на $P_1$ кончились, то остановить алгоритм.
\end{enumerate}

\subsubsection{Алгоритм распределения задач на процессоры} \label{METIS}
В качестве алгоритма распределения задач на процессоры был выбран алгоритм разбиения графа на подграфы METIS \cite{Karypis2011}. 

Для построения распределения работ на процессоры запускается алгоритм кластеризации графа с количеством кластеров, равным количеству процессоров, после чего каждый кластер распределенных задач присваивается одному процессору. 

Для задачи с дополнительным ограничением $CR$ используется взвешенное распределение METIS, где каждой вершине придается вес, равный времени выполнения задачи на процессоре. Поскольку в этой постановке проуессоры равный, конкретный процессор в которого берется время выполнения не имеет значения.

Разбиение, лучшее по балансу кластеров, может нарушать ограничение $CR$, в случае, если большие группы плотно взаимодействующих работ распределятся на разные процессоры. Эта проблема решается варьированием параметра \texttt{ufactor} алгоритма METIS, который контролирует отношение максимального количества работ в подграфе к вреднему количеству работ в подграфе. Другими словами, \texttt{ufactor} позволяет контролировать дизбаланс в количестве вершин в кластере. С увеличением этого параметра, $CR$ понижается. Для генерации распределения, удовлетворяющего дополнительное ограничение $CR$, достаточно генерировать распределения с постепенным увеличением \texttt{ufactor} до тех пор, пока очередное распределение не выполнит $CR$.

\subsubsection{Алгоритм постановки задачи на процессор} \label{gap_filling}
При постановке задачи на заданный процессор достаточно вычислить время начала выполнения задачи $t$ такое, чтобы кждое частичное расписание после добавления оставалось корректным. Начальное время $t$ выбирается как минимальное время, удовлетворяющее следующим условиям:
\begin{enumerate}
    \item Все передачи данных от предшествующих задач завершились до $t$.
    \item Существует свободный интревал времени (простой процессора или после завершения последней поставленной задачи), начинающийся в $t$ и длительностью, больший или равный времени выполнения работы, в который не выолняется ни одназ работа. В некоторых случаях, задача будет поставлена до начала другой, не свзяанной с ней задачей, в случае, если времени простоя достаточно. В сложных графах потока управления, такие простои возникают в частичных расписаниях часто, а значит всегда есть смысл их заполнять.
\end{enumerate}

