\subsection{Основные алгоритмы}
\subsubsection{Общее описание жадных алгоритмов построения многопроцессорного расписания} \label{algo_template}
Жадные алгоритмы, представленные в данной работе, построены по следующей схеме:
\begin{enumerate}
    \item \label{GC1} Выбрать работу для постановки в расписание.
    \item \label{GC2} Выбрать процессор и время начала выполнения задачи из п.\ref{GC1} на выбранном процессоре.
    \item Поставить работу на процессор.
    \item Остановиться, если все задачи поставлены, иначе перейти к п.\ref{GC1}
\end{enumerate}

Данная схема представлена на рисунке \ref{fig:block-schema}

\begin{figure}[!htbp]
    \begin{tikzpicture}
        \node (start) at (0, 0) [draw, terminal] {Начало};
        \node (decision) at (0, -2) [draw, decision, align=center] {Все работы добавлены \\ в расписание?};
        \node (finish) at (-5, -3) [draw, terminal] {Конец};
        \node (choose_task) at (0, -4.3) [draw, process] {Выбрать следующую работу для постановки};
        \node (choose_proc) at (0, -5.7) [draw, process] {Выбрать процессор для работы};
        \node (add_task) at (8, -5.7) [draw, process] {Поставить работу на процессор};

        \draw[thick, ->] (start) -- (decision);
        \draw[thick, ->] (decision) -- node[right]{Нет} (choose_task);
        \draw[thick, ->] (choose_task) -- (choose_proc);
        \draw[thick, ->] (choose_proc) -- (add_task);
        \draw[thick, ->] (add_task) |- (decision);
        \draw[thick, ->] (decision) -| node[above]{Да} (finish);
    \end{tikzpicture}
    \caption{Блок-схема жадных алгоритмов построения расписания}
    \label{fig:block-schema}
\end{figure}

\subsubsection{Жадный алгоритм c выбором по количеству потомков} \label{Greedy_GC1}
Данный алгоритм следует общей схеме, описанной в \ref{algo_template}

Эту схему можно уточнить путем выбора критерия отбора в п.\ref{GC1} и критерия выбора процессора и начала времени выполнения в п.\ref{GC2}. Для постановки задачи с дополнительными ограничениями, такого как $CR$, так же может быть неудача в постановки задачи в расписание, в случае невозможности постановки без нарушения дополнительного ограничения. В таком случае, алгоритм завершается.

Задача $d_i$ называется \textbf{доступной для постановки} в расписание, в случае, если либо у нее нет предшественников, либо все ее предшественники уже постановлены в расписание. Назовем множеством всех доступных для постановки задач $D = \left( d_0, d_1, \ldots, d_n \right)$.

Жадный алгоритм с выбором по числу потомков выбирает задачу для постановки по следующему критерию: пусть $Succ(d)$ - функция, определяющая количество непосредственных последователей работы в графе. Тогда $\forall d_j \in D, d_j \neq d_i: Succ(d_j) < Succ(d_i)$.

\begin{figure}[!htbp]
    \ctikzfig{max_children}
    \caption{Критерий выбора работы для постановки в расписание}
    \label{fig:max-children}
\end{figure}
На рисунке \ref{fig:max-children} $D = \left( x_1, x_2 \right)$, из которых $Succ(x_1) = 2, Succ(x_2) = 1$. На постановку будет выбрана вершина $x_1$.

Для постановки с дополнительным ограничением $CR$ жадный алгоритм с выбором по числу потомков берет распределение работ по процессорам из специального алгоритма распределения (описание алгоритма приведено в разделе \ref{METIS}), поэтому выбор процессора в п.\ref{GC2} всегда заранее детерминирован. Выбор начала выполнения работы в расписание производится в соответствии с алгоритмом постановки задачи на процессор (описание алгоритма приведено в разделе \ref{gap_filling}).

Для постановки без дополнительных ограничений, жадный алгоритм с выбором по числу потомков производит пробную постановку на каждый процессор и выбирает процессор с самым ранним временем завершения работы с учетом алгоритма постановки задачи на процессор (описание алгоритма приведено в разделе \ref{gap_filling}).

\subsubsection{Жадный алгоритм с EDF эвристикой} \label{Greedy_EDF}
Данный алгоритм следует общей схеме, описанной в пункте \ref{algo_template}, однако отличается от алгоритма, описанного в пункте \ref{Greedy_GC1} критерием выбора работы на постановку.

Эвристика ``самый ранний директивный срок первый'' (earliest deadline first, или \textbf{EDF}) упорядочивает работы по возрастанию директивных сроков и выбирает работу с наименьшим директивным сроком на постановку. Однако, постановка задачи не предполагает у задач директивных сроков, поэтому в данном алгоритме у каждой работы строятся фиктивные директивные сроки.

В случае, если существует директивный срок всего расписания $d$, то директивный срок $d_A$ работы $A$ может быть рассчитан следующим образом (при известном распределении работ на процессоры):
\begin{enumerate}
    \item \label{find_path} Найти длиннейший путь в графе потока управления от $A$ до работы $S: Succ(S) = \emptyset$.
    \item Рассчитать длину этого пути. Длина пути равна сумме всех передач задержек данных и времен выполнения работ. Задержки передач данных известны, так как известно распределение работ на процессоры. Пусть длина этого пути равна $p$.
    \item $d_A \coloneqq d - p$
\end{enumerate}
Видно, что работа $A$ должна завершиться до $d_A$; иначе путь, найденный в п.\ref{find_path} завершится позже, чем $d$, даже если процессоры ни имеют никакой другой нагрузки, кроме этих работ.

Даже без известного директивного срока расписания, EDF эвристика все еще может быть использована для сортировки работ по уменьшению ``потенциальной длины пути  до конца расписания'', учитывая, что расписание всегда завершится какой-либо работой $S : Succ(S) = \emptyset$. Также, нет необходимости вводить настоящие директивные сроки, в которые работы должны быть завершены. Таким образом, можно выставить директивный срок расписания в $0$, и получить формальные директивные сроки по алгоритму, представленному выше. Такие директивные сроки могут быть отрицательными, что не препятствует сортировать работы по их возрастанию.

\begin{figure}[!htbp]
    \ctikzfig{edf}
    \caption{Пример распространения фиктивных директивных сроков}
    \label{fig:edf}
\end{figure}

На рисунке \ref{fig:edf} представлен пример распространения фиктивных директивных сроков по графу потока управления. На данном примере все передачи, кроме работ $x_2$ и $x_5$, межпроцессорные. Время $d$ межпроцессорной передачи равно 2. Фиктивные директивные сроки листовых вершин $x_5$ и $x_4$ равны 0. Таким образом для расчета остальных директивных сроков:

\begin{enumerate}
    \item $x_2 = 0 - 3 \text{ (фиктивный директивный срок потомка)} = -3$
    \item $x_3 = 0 - 3 - 2 \text{ (затрата на межпроцессорную передачу)} = -5$
    \item $x_1 = \min \left(- 5 - 8 - 2, 0 - 2 - 2\right) = \min \left(-15, -4\right) = -15$, из фиктивных директивных сроков от нескольких потомков выбирается минимальный.
\end{enumerate}

Описанный алгоритм без модификаций применим к задаче с дополнительным ограничением $CR$, поскольку распределение работ на процессоры может быть рассчитано заранее, и поэтому, время задержек межпроцессорных передач известно заранее. Для данных с однородными процессорами строится взвешенное распределение (\ref{METIS}), для постановки с неоднородными процессорами строится невзвешенное распределение, которое впоследствии улучшается алгоритмом локальной оптимизации (\ref{partition_optimization}).

Однако, для постановки задачи без дополнительных ограничений привязка задач к процессорам заранее неизвестна, поэтому, для вычисления директивных сроков не учитываются задержки межпроцессорной передачи данных, а время выполнения данной задачи считается усредненным по всем процессорам. Например, если в системе три процессора, на которых задача выполняется 1, 1 и 4 у.е., то для расчета директивного срока время выполнения данной задачи считается $(1+1+4)/3 = 2$. Такая аппроксимация не нарушает работу алгоритма, поскольку директивные сроки требуется только для сортировки работ.

Жадный алгоритм с EDF эвристикой начинается с вычисления фиктивных директивных сроков, после чего выполняется цикл, описанный в \ref{algo_template}.

Еще не добавленная работа с минимальным фиктивным директивным сроком выбирается как очередной кандидат на добавление в расписание.

Аналогично алгоритму, описанному в \ref{Greedy_GC1}, для задачи с дополнительным ограничением $CR$ для выбора процессора для постановки очередной задачи используется распределение, построенное алгоритмом распределения задач на процессоры (\ref{METIS}), а для постановки без дополнительных ограничений производит пробную постановку на каждый процессор с самым ранним временем завершения работы с учетом алгоритма постановки задачи на процессор (\ref{gap_filling}).

\subsection{Вспомогательные алгоритмы}

\subsubsection{Алгоритм локальной оптимизации распределения} \label{partition_optimization}

Этот алгоритм используется только для постановки $CR$ с неоднородными процессорами. Подразумевается, что процессоры упорядочены по возрастанию производительности, то есть для любых процессоров $P_1, P_2$, если работа $A$ выполняется на процессоре $P_1$ дольше, чем на $P_2$, то и работа $B$ выполняется на процессоре $P_1$ дольше, чем на $P_2$. Таким образом, если переназначить работу с $P_1$ на $P_2$, то время выполнения расписания сократится.

С примерно равным количеством работ на всех процессорах на невзвешенном распределении METIS, самые медленные процессору будут самыми загруженными. Задача данного алгоритма - "разгрузить" самые загруженные процессоры путем перемещения работ с него на менее загруженные процессоры.

Алгоритм имеет следующую структуру:
\begin{enumerate}
    \item Выбрать самый загруженный процессор $P_1$
    \item Для каждой работы $A$, поставленной на $P_1$, в порядке убывания времени выполнения:
          \begin{enumerate}
              \item \label{item:choose_proc} Выбрать самый быстрый процессор $P_2$ из процессоров, удовлетворяющих следующее условие: если перенести работу $A$ с $P_1$ на $P_2$, то $\max(\text{загрузка} P_1, \text{загрузка} P_2)$ уменьшается и выполняется ограничение $CR$
              \item Если такой $P_2$ был найден, то перенести эту задачу и перейти к пункту \ref{item:choose_proc}; иначе рассмотреть следующую по времени выполнения задачу на $P_1$.
          \end{enumerate}
    \item Если задачи на $P_1$ кончились, то остановить алгоритм.
\end{enumerate}

\subsubsection{Алгоритм распределения задач на процессоры} \label{METIS}
В качестве алгоритма распределения задач на процессоры был выбран алгоритм распределения графа на подграфы METIS \cite{Karypis2011}.

Для построения распределения работ на процессоры запускается алгоритм кластеризации графа с количеством кластеров, равным количеству процессоров, после чего каждый кластер распределенных задач присваивается одному процессору.

Для задачи с дополнительным ограничением $CR$ используется взвешенное распределение METIS, где каждой вершине придается вес, равный времени выполнения задачи на процессоре. Поскольку в этой постановке процессоры равный, конкретный процессор в которого берется время выполнения не имеет значения.

Распределение, лучшее по балансу подграфов, может нарушать ограничение $CR$, в случае, если большие группы плотно взаимодействующих работ распределятся на разные процессоры. Эта проблема решается варьированием параметра \texttt{ufactor} алгоритма METIS, который контролирует отношение максимального количества работ в подграфе к вреднему количеству работ в подграфе. Другими словами, \texttt{ufactor} позволяет контролировать дисбаланс в количестве вершин в кластере. С увеличением этого параметра, $CR$ понижается. Для генерации распределения, удовлетворяющего дополнительное ограничение $CR$, достаточно генерировать распределения с постепенным увеличением \texttt{ufactor} до тех пор, пока очередное распределение не выполнит $CR$.

\subsubsection{Алгоритм постановки задачи на процессор} \label{gap_filling}
При постановке задачи на заданный процессор достаточно вычислить время начала выполнения задачи $t$ такое, чтобы каждое частичное расписание после добавления оставалось корректным. Начальное время $t$ выбирается как минимальное время, удовлетворяющее следующим условиям:
\begin{enumerate}
    \item Все передачи данных от предшествующих задач завершились до $t$.
    \item Существует свободный интервал времени (простой процессора или после завершения последней поставленной задачи), начинающийся в $t$ и длительностью, больший или равный времени выполнения работы, в который не выполняется ни одна работа. В некоторых случаях, работа будет поставлена до начала другой, не свзяанной с ней работы, в случае, если времени простоя достаточно. В сложных графах потока управления, такие простои возникают в частичных расписаниях часто, а значит всегда есть смысл их заполнять.
\end{enumerate}

\begin{figure}[!htbp]
    \centering
    \small
    \begin{subfigure}{0.49\textwidth}
        \ctikzfig{schedule-time-diagram-2}
        \caption{До добавления}
        \label{fig:sched-before-addition}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.49\textwidth}
        \ctikzfig{schedule-time-diagram-3}
        \caption{После добавления}
        \label{fig:sched-after-addition}
    \end{subfigure}
    \caption{Добавление задачи $T_7$ в расписание}
\end{figure}

Пусть до добавления работы $T_7$ расписание находится в состоянии \ref{fig:sched-before-addition}. $T_7$ распределена на процессор $Pr3$ и имеет длительность 1, имеет одного предка $T_2$, поставленного на процессор $Pr2$. Длительность межпроцессорной передаче равна 1. Таким образом, есть возможность поставить работу в простой, начинающийся в отрезок времени 3, как на рисунке \ref{fig:sched-after-addition}.