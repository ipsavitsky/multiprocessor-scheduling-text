% Обзоры других алгоритмов приведены в \cite{Shakhbazyan_1981,Davis_2011}
\subsection{Критерии обзора}
Ниже приведены критерии, по которым будут рассматриваться и сравниваться алгоритмы
\begin{enumerate}
    % \item Насколько сильно рассматриваемая в статье задача отличается от решаемой. Можно ли взять алгоритм, описанный в статье за базу для алгоритма для решения данной задачи.
    % \item Точность решений, строимых рассмотренными алгоритмов
    % \item Порядок сложности алгоритма, насколько он масштабируемый.
    % \item На данных какой размерности протестирован алгоритм. Время его работы.
    \item Возможность модифицировать алгоритм под поставленную задачу. Из необходимых модификаций требуется добавить возможность учета дополнительного критерия межпроцессорных передач и возможность учета затрат на межпроцессорные передачи.
    \item Возможность масштабирования алгоритма. 
\end{enumerate}
\subsection{Конструктивные алгоритмы}
\subsubsection{Жадные алгоритмы}
Жадные алгоритмы подразумевают декомпозицию задачи на ряд более простых подзадач. На каждом шаге решение принимается исходя из принципа получения оптимального решения для очередной подзадачи. То есть, на каждом шаге алгоритм делает выбор, оптимальный с точки зрения получения решения очередной подзадачи, предполагая, что эти локально-оптимальные решения приведут к приемлемому решению задачи. Какие-либо жадные стратегии, гарантированно получающие оптимальное расписание, на настоящий момент времени неизвестны, за исключением небольшого числа вариантов задач составления расписаний не принадлежащих к классу NP-полных. Например, известен жадный алгоритм, получающий точное решение для задачи обслуживания одним процессором максимального числа работ из заданного набора работ с фиксированными сроками начала и окончания \cite{Cormen}. Набор локальных критериев оптимизации сильно зависит от класса архитектуры. Для архитектур, в которых возможно последействие (распределяемый в расписание рабочий интервал оказывает влияние на времена инициализации ранее распределенных рабочих интервалов) возникает проблема выбора локальных критериев оптимизации, позволяющих учесть эффект последействия (на настоящий момент времени какие-либо обоснованные решения этой проблемы не известны). Кроме того, единого локального критерия (или набора и способа их использования), приводящего к наилучшему конечному результату, для решения всех подзадач не существует. Более того, при усложнении архитектуры набор и способ использования локальных критериев оказывает более сильное влияние на конечный результат. Таким образом, применение жадных алгоритмов для составления расписаний классом архитектур без последействия или даже без разделяемых ресурсов, если их влияние на значение функции построения временной диаграммы не может быть локализовано, а также проблемой выбора критериев оптимизации индивидуально для каждой подзадачи.

При построении расписания жадным алгоритмом для каждой заадчи необходимо определить два параметра:
\begin{enumerate}
    \item Привязку задачи к процессору $p_i$
    \item Время старта задачи на процессоре $s_i$
\end{enumerate}
Каждый из этих параметров может быть определен своим жадным критерием. Время старта (как показано в \cite{Kalashnikov_2004}) единственным образом определяется из порядка работ на процессоре. Следовательно, имеет роль порядок, в котором работы добавляются в расписание.

Таким образом, для построения расписания достаточно определить:
\begin{enumerate}
    \item Привязку задачи к процессору $p_i$
    \item Ее номер в очереди на добавление в расписание $q_i$
\end{enumerate}

\subsubsection{Алгоритмы, основанные на методе динамического программирования}

Алгоритмы динамического программирования разбивают сложную задачу на более простые подзадачи и находят обратную связь между их оптимальными решениями. Алгоритмы из этой области могут предоставлять глобальные оптимальные решения, но их недостатком является неполиномиальная сложность. В частности, с точки зрения NP-сложных задач планирования сложность этих алгоритмов является экспоненциальной функцией размера входных данных. Кроме того, для нахождения обратной зависимости между оптимальными решениями и подзадачами необходима модель аналитической системы. Это означает, что алгоритм не подходит для решения данной задачи, так как имеет высокую вычислительную сложность \cite{Dynamic_prog}.

\subsubsection{Алгоритмы, основанные на методе ветвей и границ}

Алгоритм ветвей и границ является эффективным методом решения производных задач оптимизации. Этот метод делит пространство потенциальных решений на различные области, дает точные оценки их значения по отношению к целевой функции и сокращает ненужные участки, где невозможно найти оптимальное решение. Хотя глобальные оптимальные решения могут быть получены с помощью этого метода, его сложность для большинства задач комбинаторной оптимизации неполиномиальна. Особенно для NP-сложных задач планирования сложность является факториальной функцией размера входных данных. Следовательно, эти алгоритмы не подходят для решения проблемы.

Алгоритм, обсуждаемый в \cite{Rahman2009BranchAB}, был протестирован с использованием наборов данных с числом процессоров до 16 и графов, содержащих до 100 вершин. Результаты показали ожидаемый экспоненциальный рост времени работы.

\subsubsection{Алгоритмы, основанные на нахождении максимального потока в сети}

Алгоритмические методы составления многопроцессорных расписаний включают поиск максимального потока в транспортной сети, которые, по сути, переводят процесс построения расписания в поиск максимально возможного потока в указанной сети. Указанная сеть строится на основе набора задач, процессоров и параметров исходного задания. После построения сети выполняется процесс поиска максимального потока. Затем, с помощью значений потока в сети, возможно построить многопроцессорное расписание \cite{MAGIROU1989351}. Этот конкретный алгоритм подходит только для задач, допускающих прерывания в вычислительной системе, поэтому в данной задаче его нельзя использовать.

% \subsection{Итерационные алгоритмы}

% \subsubsection{Генетические алгоритмы}

% Такие алгоритмы используют селекцию, кроссинговер и мутацию, чтобы оптимизировать набор решений, называющийся популяцией, при этом сохраняя среди них достаточное разнообразие чтобы не находить решения в локальных минимумах.

% Недостатком этого типа алгоритмов является отсутствие масштабируемости. По мере увеличения использования становится все труднее управлять системой или масштабировать ее для различных задач. Результаты исследования в статье демонстрируют, что алгоритм не имеет высокой производительности при использовании больших объемов данных. Разобранный в \cite{Sheikh2016AnET} алгоритм смог обработать задачу, содержащую 1000 заданий, за 1,5 часа на процессоре с частотой 2 ГГц. Хотя это может показаться длительным временем выполнения, это в значительной степени связано с тем, что генетические и эволюционные алгоритмы требуют наличия множества решений, доступных в популяциях для реализации.

% \subsubsection{Алгоритм имитации отжига}

% Алгоритмы имитации отжига хорошо подходят для нахождения приближенных решений NP-сложных задач комбинаторной оптимизации. Эти алгоритмы позволяют решать проблемы с помощью стохастических шагов, гарантируя получение наилучшего решения \cite{Kalashnikov_2004}.

% Имитация отжига может эффективно обрабатывать большие наборы данных, так как этот алгоритм работает с одним решением. В отличие от генетических и эволюционных алгоритмов, это делает его более масштабируемым.

% \subsubsection{Алгоритм муравьиных колоний}

% Муравьиные алгоритмы - это методы оптимизации, которые используют положительную и отрицательную обратную связь для поиска оптимального пути \cite{Shtovba_2005}. Они находят широкое применение в различных задачах оптимизации, но могут столкнуться с проблемой преждевременной сходимости, что может привести к неоптимальным результатам. Важным аспектом применения муравьиных алгоритмов является тщательная настройка и учет особенностей конкретной задачи, чтобы достичь наилучшего результата.

\subsection{Выводы из обзора предметной области}
% Итерационные алгоритмы работают путем создания аппроксимированного варианта решения и последующего его улучшения. Однако, большинство из них рандомизированные и, следовательно, из нескольких различных запусков теоретически возможно получить различные расписания (несмотря на то то они все сходятся). Более того, многие из таких алгоритмов плохо масштабируемы. Муравьиные алгоритмы разобраны в \cite{Shtovba_2005}, имитации отжига - в \cite{Kirkpatrick_1983}.
% \begin{table}[htbp!]
%     \begin{tabularx}{\textwidth}{ | X | l | X | X | }
%         \hline
%         Название алгоритма            & Рандомизированность & Класс алгоритмa  & Возможность  масштабирования \\
%         \hline
%         Генетические алгоритмы        & Рандомный           & Итерационный    & +/-                          \\
%         \hline
%         Алгоритм имитации отжига      & Рандомный           & Итерационный    & +                            \\
%         \hline
%         Муравьиные алгоритмы          & Рандомный           & Итерационный    & -                            \\
%         \hline
%         Жадные стратегии              & Детерминированный   & Конструктивный  & +                            \\
%         \hline
%         Динамическое программирование & Детерминированный   & Конструктивный  & -                            \\
%         \hline
%         Ветви и границы               & Детерминированный   & Конструктивный  & -                            \\
%         \hline
%         Максимальный поток            & Детерминированный   & Конструктивный & -                            \\
%         \hline
%     \end{tabularx}
%     \caption{Существующие алгоритмы}
%     \label{tbl:review}
% \end{table}

\newcolumntype{Y}{>{\centering\arraybackslash}X}

\begin{table}[!htbp]
    \begin{tabularx}{\textwidth}{  c | Y | Y }
        Название алгоритма                   & Возможность модификации алгоритма & Возможность масштабирования алгоритма \\
        \hline
        Метод ветвей и границ                & \ding{51}                         & \ding{55}                             \\
        Метод динамического программирования & \ding{51}                         & \ding{55}                             \\
        Алгоритм поиска максимального потока & \ding{55}                         & \ding{51}                             \\
        Жадные алгоритмы                     & \ding{51}                         & \ding{51}                             \\
    \end{tabularx}
    \caption{Существующие детерминированные алгоритмы}
    \label{tbl:review}
\end{table}

В таблице \ref{tbl:review} представлены сокращенные результаты обзора.

В результате обзора предметной области, под критерии масштабируемости и соответствия задаче подходит жадный алгоритм. По результатам не было найдено работ, точно соответствующим постановке задачи, поэтому предложенный подход требуется модифицировать.
% Обзоры этих алгоритмов для схожих задач представлены в \cite{Coffman,Davis_2011,Shakhbazyan_1981}
